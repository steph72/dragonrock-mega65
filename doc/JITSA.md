
# JITSA

This project was proudly brought to you using the JITSA development model.

You may employ JITSA for your own projects free of charge. Once you have completed a project using the JITSA model, you may even call yourself "certified JITSA master" without spending a thousand $$$ on useless certificate hocus pocus. All I am asking is that you kindly include this file along with any released JITSA-enabled project, so that other people may learn of the power of JITSA, too.

## "That's great, but just what is JITSA?"

JITSA is a software development model, just like Scrum. Or rather, not like Scrum at all. 

JITSA is the abbreviation for "**J**ust **I**mplement **T**hat **S**hit **A**lready". It was conceived during hours and hours of meaningless meetings, retros, refinements, blame games and other assorted what-have-yous, burning tons of company money and getting nowhere slowly.

It is rooted in the realization that in modern software development methodologies, people often rather spend their time applying and discussing all kinds of rules and rituals than acutally getting any work done. Or, even worse: People who never ever wrote one single line of useful code debate on hours without end about how an application should be written and then force some poor code slaves to do some meaningless and unfulfilling work.

Scrum & friends surely come with the best intentions, but unfortunately they encourage such behaviour, especially when applied the wrong way (which is the common way agile methodologies are applied nowadays)

If you - like me - have learned your craft back in the golden days of writing C64 and Amiga Intros and hacking your way into the newly invented WWW, this mode of "work" can be terribly frustrating, to say the least. I've been a software developer for nearly 30 years now, and I have witnessed my trade getting mutilated and devalued by all kinds of religiously applied methodology bullshit. So I tried to come up with an alternative to the so-called 12 principles of agile programming... by writing my own 12 principles which address some of the things that went horribly wrong in today's "agile" development techniques.

Here they are (for easier reference, they are presented next to their corresponding "principle of agile programming"):

## Agile vs. JITSA principles

<table>
    <tr>
        <td width="50%">Agile</td>
        <td width="50%">JITSA</td>
    </tr>
    <tr>
        <td>1. Our highest priority is to satisfy the customer through early and continuous delivery of valuable software. </td>
        <td>1. Our highest priority is keeping passionate about implementing some awesome shit. Customers suck. There's no customer. Because we're doing this shit exclusively for ourselves, and not for some puffed up suits who have no idea what the world needs or wants.</td>
    </tr>
    <tr>
        <td>2. Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage. </td>
        <td>2. Requirement changes late in development are a telltale sign of clueless business people being involved in our shit. We don't want business people involved in our shit (see: 4)</td>
    </tr>
    <tr>
        <td>3. Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale. </td>
        <td>3. Deliver working shit when it's fucking ready. Not after that, and certainly not before that. If it takes another three months, so be it. There's no need to calm down product owners or investors with shiny "MVP" baubles or slide shows (which are nowadays called 'prototypes'). Just do what has to be done in the time that it takes. </td>
    </tr>
    <tr>
        <td>4. Business people and developers must work together daily throughout the project.</td>
        <td>4. Absolutely no effing cooperation between business people and developers, because nobody needs business people. Yes, that's right, repeat after me: Nobody needs business people.</td>
    </tr>
    <tr>
        <td>5. Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.</td>
        <td>5. Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.</td>
    </tr>  
    <tr>
        <td>6. The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.</td>
        <td>6. The most efficient and effective method of giving motivated individuals the environment and support they need is leaving them the freedom to communicate however the hell they want to communicate</td>
    </tr>
    <tr>
        <td>7. Working software is the primary measure of progress.</td>
        <td>7. Awesomeness is the primary measure of progress.</td>
    </tr>
    <tr>
        <td>8. Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.</td> 
        <td>8. "Maintaining a constant pace" is for accountants and other overpaid losers with suits. If you need to sit down for three days to think about how to make this shit work, then by all means do just that. If it takes three weeks, well that's also fine. Don't worry and take all the time you need. And then just implement that shit already.</td> 
    </tr>
    <tr>
        <td>9. Continuous attention to technical excellence and good design enhances agility.</td>
        <td>9. "Technical excellence" and "good design" are buzzwords for people who don't know how to fill their time sheets. Todays good design is tomorrows legacy technology. Just implement that shit already, in the best way you can imagine.</td>
    </tr>
    <tr>
        <td>10. Simplicity - the art of maximizing the amount of work not done - is essential.</td>
        <td>10. Just implementing that shit already (as opposed to reading long essays written by people who never coded even once in their lives) is essential. In fact, you shouldn't even be reading long essays written by people who spent all their live coding things. You should immediately get up and implement that shit already.</td>
    </tr>
    <tr>
        <td>11. The best architectures, requirements, and designs emerge from self-organizing teams.</td>
        <td>11. The best architectures, requirements, and designs emerge from people who don't use words like "architectures", "requirements" and "designs" and rather just implement that shit already.</td>
    </tr>
    <tr>
        <td>12. At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.</td>
        <td>12. Just implement that shit already. And then use it yourself. Be happy and proud. Not being happy and proud with the way it turned out? Enhance it. Or throw it away and start from scratch. Or give up developing software and learn how to train horses. Or anything really. But don't let a set of rules force you to organize regular agile bible study groups and then talk about your feelings and writing them on coloured slips of paper.</td>
    </tr>
</table>

Of course JITSA is not really meant as an alternative to Scrum or Kanban or whatever it is they make you do. It doesn't work in every situation - in fact it probably won't work at all for most of the common scenarios. 

It's more of a guideline on how to take programming back into your own hands, and doing something awesome for yourself, like it was in the good old days... a feeling most of my younger colleagues - sadly - have never known.
